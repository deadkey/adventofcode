{
    "Nint": {
      "prefix": "N",
      "body": "N = int(raw_input())",
      "description": "N int"
    },
    "input": {
      "prefix": "mir",
      "body": "[int(v) for v in raw_input().split()]",
      "description": "input"
    },
    "debug": {
      "prefix": "debug",
      "body": "DEBUG = True\ndef debug(*s):\n    p = ' '.join(map(str, s))\n    if DEBUG:\n        print(p)\n",
      "description": "debug"
    },
    "inf": {
      "prefix": "INF",
      "body": "INF = 10**12",
      "description": "inf"
    },
    "read": {
      "prefix": "ra",
      "body": "raw_input()",
      "description": "read"
    },
    "readint": {
      "prefix": "in",
      "body": "int(raw_input())",
      "description": "readint"
    },
    "readandsplit": {
      "prefix": "ras",
      "body": "raw_input().split()",
      "description": "readandsplit"
    },
    "gcd": {
      "prefix": "gcd",
      "body": "def gcd(a, b):return gcd(b, a % b) if b else a\n",
      "description": "gcd"
    },
    "forloop": {
      "prefix": "forn",
      "body": "for n in range(N):\n   ",
      "description": "forloop"
    },
    "bfs": {
      "prefix": "bfs",
      "body": "def bfs(q, g):\n    visited = [False] * N\n    for node in q:\n        visited[node] = True\n    while q:\n        q2 = []\n        for node in q:\n            for ne in g[node]:\n                if not visited[ne]:\n                    visited[ne] = True\n                    q2.append(ne)\n        q = q2\n    return visited",
      "description": "bfs"
    },
    "convex_hull": {
      "prefix": "convexhull",
      "body": "def convex_hull(points):\n    points = sorted(set(points))\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    # Build upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]",
      "description": "convex_hull"
    },
    "unionfind": {
      "prefix": "UF",
      "body": "parents = []\ndef find(x):\n    if parents[x][0] != x:\n        parents[x][0] = find(parents[x][0])\n    return parents[x][0]\n\ndef add(a, a_parent, b_parent):\n\n    p,size= parents[b_parent]\n    size += parents[a_parent][1]\n    parents[b_parent] =  [b_parent, size]\n    parents[a_parent][0] = b_parent\n\ndef union(a,b):\n    a_parent = find(a)\n    b_parent = find(b)\n    if a_parent == b_parent:\n        return False\n\n    if parents[a_parent][1] < parents[b_parent][1]:\n        add(a,a_parent, b_parent)\n    else:\n        add(b, b_parent,a_parent)\n    return True",
      "description": "unionfind"
    },
    "top": {
      "prefix": "top",
      "body": [
        "#returns order so that edges only point forward in partial order",
        "def topsort(g):",
        "    ps=[0] * len(g)",
        "    for ns in g:",
        "        for n in ns:",
        "            ps[n] += 1",
        "    q =[i for i,v in enumerate(ps) if v == 0]",
        "    order = []",
        "    while q:",
        "        q2 = []",
        "        for n in q:",
        "            order.append(n)",
        "            for p in g[n]:",
        "                ps[p] -=1",
        "                if ps[p] == 0:",
        "                    q2.append(p)",
        "        q =q2",
        "    return order",
        ""
      ],
      "description": "topsort"
    },
    "itr": {
      "prefix": "itr",
      "body": [
        "import sys",
        "",
        "itr = (line for line in sys.stdin.read().split('\\n'))"
      ],
      "description": "itreator"
    },
    "nextitr": {
      "prefix": "ne",
      "body": [
        "next(itr)"
      ],
      "description": ""
    },
    "lines": {
      "prefix": "lines",
      "body": [
        "import sys",
        "",
        "lines = sys.stdin.readlines()"
      ],
      "description": "sys lines"
    },
    "lcm": {
      "prefix": "lcm",
      "body": [
        "def lcm(a, b): return a*b//gcd(a,b)"
      ],
      "description": "lcm"
    },
    "fort": {
      "prefix": "fort",
      "body": [
        "T = int(raw_input())",
        "for t in range(T):",
        "    "
      ],
      "description": "fort"
    },
    "codejam": {
      "prefix": "codejam",
      "body": [
        "inp = input",
        "",
        "def nl():",
        "    return [int(v) for v in inp().split()]",
        "",
        "def solve(S):",
        "    return ''",
        "    ",
        "T = int(inp())",
        "for t in range(T):",
        "    N = int(inp())",
        "    S = nl()",
        "    R = solve(S)",
        "",
        "    print('Case #{}: {}'.format(t+1, R))"
      ],
      "description": "codejam teplate"
    },
    "fenwick": {
      "prefix": "fenwick",
      "body": [
        "arr = [0] * (N + 1) #1-indexed!!!!!!",
        "def inc(arr, i, val):",
        "    private_inc(arr, i + 1, val)",
        "",
        "def sum(arr, a):",
        "    return private_sum(arr, a)",
        "",
        "def private_inc(arr, i, val):",
        "    while i < len(arr):",
        "        arr[i] += val",
        "        i += i & -i",
        "",
        "def private_sum(arr, i):",
        "    s = 0",
        "    while i > 0:",
        "        s += arr[i]",
        "        i -= i & -i",
        "    return s"
      ],
      "description": "fenwick"
    },
    "dijkstra": {
      "prefix": "dij",
      "body": [
        "",
        "import heapq",
        "",
        "def dij(S, g):",
        "    #g list with lists with tuples distance, other node",
        "    # Dijkstra from S. Check t optionally",
        "    INF = 10**12",
        "    N = len(g)",
        "    dist = [INF for _ in range(N)]",
        "",
        "    pq = []",
        "    dist[S] = 0",
        "    pq.append((0, S))",
        "    heapq.heapify(pq)",
        "    done = False",
        "    while pq and not done:",
        "        (nd, node) = heapq.heappop(pq)",
        "        #if node == T: return dist[T]",
        "        for (dd, nn) in g[node]:",
        "            alt = dist[node] + dd",
        "            if dist[nn] > alt:",
        "                dist[nn] = alt",
        "                heapq.heappush(pq, (dist[nn], nn))",
        "",
        "    return dist"
      ],
      "description": "dikstras"
    },
    "readinput": {
      "prefix": "nl",
      "body": [
        "import sys",
        "",
        "itr = (line for line in sys.stdin.read().split('\\n'))",
        "def inp(): return next(itr)",
        "def nl(): return [int(v) for v in inp().split()]",
        "def ni(): return int(inp())"
      ],
      "description": "inputtemplate"
    },
    "geom": {
      "prefix": "geom",
      "body": [
        "import math",
        "",
        "# Distance between two points ",
        "def dist(p, q):",
        "  return math.hypot(p[0]-q[0], p[1] - q[1])",
        "",
        "# Square distance between two points",
        "def d2(p, q):",
        "  return (p[0] - q[0])**2 + (p[1] - q[1])**2",
        "",
        "# Converts two points to a line (a, b, c), ",
        "# ax + by + c = 0",
        "# if p == q, a = b = c = 0 ",
        "def pts2line(p, q):",
        "  return (-q[1] + p[1], ",
        "          q[0] - p[0], ",
        "          p[0]*q[1] - p[1]*q[0])",
        "",
        "# Distance from a point to a line, ",
        "# given that a != 0 or b != 0 ",
        "def distl(l, p):",
        "  return (abs(l[0]*p[0] + l[1]*p[1] + l[2])",
        "      /math.hypot(l[0], l[1]))",
        "",
        "# intersects two lines.",
        "# if parallell, returnes False.",
        "def inters(l1, l2):",
        "  a1,b1,c1 = l1",
        "  a2,b2,c2 = l2",
        "  cp = a1*b2 - a2*b1 ",
        "  if cp != 0:",
        "    return float(b1*c2 - b2*c1)/cp, float(a2*c1 - a1*c2)/cp",
        "  else:",
        "    return False",
        "",
        "# projects a point on a line",
        "def project(l, p):",
        "  a, b, c = l",
        "  return ((b*(b*p[0] - a*p[1]) - a*c)/(a*a + b*b), ",
        "    (a*(a*p[1] - b*p[0]) - b*c)/(a*a + b*b))",
        "",
        "# Intersections between circles",
        "def intersections(c1, c2):",
        "  if c1[2] > c2[2]:",
        "      c1, c2 = c2, c1",
        "  x1, y1, r1 = c1",
        "  x2, y2, r2 = c2",
        "  if x1 == x2 and y1 == y2 and r1 == r2:",
        "    return False",
        "",
        "  dist2 = (x1 - x2)*(x1-x2) + (y1 - y2)*(y1 - y2)",
        "  rsq = (r1 + r2)*(r1 + r2)",
        "  if dist2 > rsq or dist2 < (r1-r2)*(r1-r2):",
        "    return []",
        "  elif dist2 == rsq:",
        "    cx = x1 + (x2-x1)*r1/(r1+r2)",
        "    cy = y1 + (y2-y1)*r1/(r1+r2)",
        "    return [(cx, cy)]",
        "  elif dist2 == (r1-r2)*(r1-r2):",
        "    cx = x1 - (x2-x1)*r1/(r2-r1)",
        "    cy = y1 - (y2-y1)*r1/(r2-r1)",
        "    return [(cx, cy)]",
        "",
        "  d = math.sqrt(dist2)",
        "  f = (r1*r1 - r2*r2 + dist2)/(2*dist2)",
        "  xf = x1 + f*(x2-x1)",
        "  yf = y1 + f*(y2-y1)",
        "  dx = xf-x1",
        "  dy = yf-y1",
        "  h = math.sqrt(r1*r1 - dx*dx - dy*dy)",
        "  norm = abs(math.hypot(dx, dy))",
        "  p1 = (xf + h*(-dy)/norm, yf + h*(dx)/norm)",
        "  p2 = (xf + h*(dy)/norm, yf + h*(-dx)/norm)",
        "  return sorted([p1, p2])",
        "",
        "# Finds the bisector through origo",
        "# between two points by normalizing.",
        "def bisector(p1, p2):",
        "  d1 = math.hypot(p1[0], p2[1])",
        "  d2 = math.hypot(p2[0], p2[1])",
        "  return ((p1[0]/d1 + p2[0]/d2),",
        "          (p1[1]/d1 + p2[1]/d2))",
        "",
        "# Distance from P to origo",
        "def norm(P):",
        "  return (P[0]**2 + P[1]**2 + P[2]**2)**(0.5)",
        "",
        "# Finds ditance between point p",
        "# and line A + t*u in 3D",
        "def dist3D(A, u, p):",
        "  AP = tuple(A[i] - p[i] for i in range(3))",
        "  cross = tuple(AP[i]*u[(i+1)%3] - AP[(i+1)%3]*u[i] ",
        "    for i in range(3))",
        "  return norm(cross)/norm(u)",
        "",
        "def vec(p1, p2):",
        "    return p2[0]-p1[0], p2[1] - p1[1]",
        "",
        "def sign(x):",
        "    if x < 0: return -1",
        "    return 1 if x > 0 else 0",
        "",
        "def cross(u, v):",
        "    return u[0] * v[1] - u[1] * v[0]",
        "",
        "# s1: (Point, Point)",
        "# s2: (Point, Point)",
        "# Point : (x, y)",
        "# returns true if intersecting s1 & s2 shares at least 1 point.",
        "def segment_intersect(s1, s2):",
        "    u = vec(*s1)",
        "    v = vec(*s2)",
        "    p1, p2 = s1",
        "    q1, q2 = s2",
        "    d1 = cross(u, vec(p1, q1))",
        "    d2 = cross(u, vec(p1, q2))",
        "    d3 = cross(v, vec(q1, p1))",
        "    d4 = cross(v, vec(q1, p2))",
        "    if d1 * d2 * d3 * d4 == 0:",
        "        return True    ",
        "    return sign(d1) != sign(d2) and sign(d3) != sign(d4)",
        ""
      ],
      "description": "geom"
    },
    "trie": {
      "prefix": "trie",
      "body": [
        "from typing import Tuple",
        "",
        "",
        "class Trie:",
        "    ",
        "    def __init__(self, char: str):",
        "        self.char = char",
        "        self.children = []",
        "        self.word_finished = False",
        "        self.counter = 1",
        "    ",
        "",
        "def add(root, word: str):",
        "    node = root",
        "    for char in word:",
        "        found_in_child = False",
        "        for child in node.children:",
        "            if child.char == char:",
        "                child.counter += 1",
        "                node = child",
        "                found_in_child = True",
        "                break",
        "        if not found_in_child:",
        "            new_node = Trie(char)",
        "            node.children.append(new_node)",
        "            # And then point node to the new child",
        "            node = new_node",
        "    node.word_finished = True",
        "",
        "",
        "def find_prefix(root, prefix):",
        "    node = root",
        "    if not root.children:",
        "        return False, 0",
        "    for char in prefix:",
        "        char_not_found = True",
        "        for child in node.children:",
        "            if child.char == char:",
        "                char_not_found = False",
        "                node = child",
        "                break",
        "        if char_not_found:",
        "            return False, 0",
        "    return True, node.counter"
      ],
      "description": "trie"
    },
    "crt": {
      "prefix": "crt",
      "body": [
          "#If a list of t = a1 mod n1, t = a2 mod n2 ... Given a list of a and n, returns t ",
          "def crt(la, ln):",
          "\tassert len(la) == len(ln)",
          "\tfor i in range(len(la)):",
          "\t\tassert 0 <= la[i] < ln[i]",
          "\tprod = 1",
          "\tfor n in ln:",
          "\t\tassert gcd(prod, n) == 1",
          "\t\tprod *= n",
          "\tlN = []",
          "\tfor n in ln:",
          "\t\tlN.append(prod//n)",
          "\tx = 0",
          "\tfor i, a in enumerate(la):",
          "\t\tprint(lN[i], ln[i])",
          "\t\t_, Mi, mi = xgcd(lN[i], ln[i])",
          "\t\tx += a*Mi*lN[i]",
          "\treturn x % prod"
      ],
      "description": "description",
    },
    "xgcd": {
      "prefix": "xgc",
      "body": [
          "# x * a + y * b = gcd(a, b). Return gcd(a, b), x, y",
          "def xgcd(a, b):",
          "    x0, x1, y0, y1 = 1, 0, 0, 1",
          "    while b != 0:",
          "        q, a, b = (a // b, b, a % b)",
          "        x0, x1 = (x1, x0 - q * x1)",
          "        y0, y1 = (y1, y0 - q * y1)",
          "    return (a, x0, y0)"
      ],
      "description": "xgcd"
    },
    "setbfs": {
      "prefix": "bfss",
      "body": [
          "",
          "def bfs(q, g):",
          "\tvisited = set()",
          "\tfor node in q:",
          "\t\tvisited.add(node)",
          "\twhile q:",
          "\t\tq2 = []",
          "\t\tfor node in q:",
          "\t\t\tfor ne in g[node]:",
          "\t\t\t\tif ne not in visited:",
          "\t\t\t\t\tvisited.add(ne)",
          "\t\t\t\t\tq2.append(ne)",
          "\t\tq = q2",
          "\treturn visited"
      ],
      "description": "description",
  },
  "flow": {
    "prefix": "flow",
    "body": [
        "from collections import defaultdict",
        "class Flow:",
        "\tdef __init__(self, sz):",
        "\t\tself.G = [",
        "\t\t\tdefaultdict(int) for _ in range(sz)",
        "\t\t] # neighbourhood dict, N[u] = {v_1: cap_1, v_2: cap_2, ...\\}",
        "\t\tself.Seen = set() # redundant",
        "\t",
        "\tdef add_edge(self, u, v, cap):",
        "\t\t\"\"\" Increases capacity on edge (u, v) with cap. ",
        "\t\t\tNo need to add the edge \"\"\"",
        "\t\tself.G[u][v] += cap",
        "\t",
        "\tdef max_flow(self, source, sink):",
        "\t\tdef dfs(u, hi):",
        "\t\t\tG = self.G",
        "\t\t\tSeen = self.Seen",
        "\t\t\tif u in Seen: return 0",
        "\t\t\tif u == sink: return hi",
        "\t\t\t",
        "\t\t\tSeen.add(u)",
        "\t\t\tfor v, cap in G[u].items():",
        "\t\t\t\tif cap >= self.min_edge:",
        "\t\t\t\t\tf = dfs(v, min(hi, cap))",
        "\t\t\t\t\tif f:",
        "\t\t\t\t\t\tG[u][v] -= f",
        "\t\t\t\t\t\tG[v][u] += f",
        "\t\t\t\t\t\treturn f",
        "\t\t\treturn 0",
        "",
        "\t\tflow = 0",
        "\t\tself.min_edge = 2**30 # minimal edge allowed",
        "\t\twhile self.min_edge > 0:",
        "\t\t\tself.Seen = set()",
        "\t\t\tpushed = dfs(source, float('inf'))",
        "\t\t\tif not pushed:",
        "\t\t\t\tself.min_edge //= 2",
        "\t\t\tflow += pushed",
        "\t\treturn flow",
        "",
        ""
    ],
    "description": "description",
  },
  
  }